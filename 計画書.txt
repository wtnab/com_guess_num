４桁の数を推測するアルゴリズム
数は４桁で、各桁に異なる数が用いられている

数は既に与えられているとする
while 正解するまで：
  ズレの情報に基いて数を推測
  正解と推測とのズレが与えられる

ズレの情報に基いて数を推測
ズレの情報はi-EAT, j-BITEで与えられる
iは「数字も桁も合っているものの数」
jは「数字は合っているが桁が違う数」

ズレの情報が与えられていゆく毎に、正解としてあり得る数の範囲が狭まる。
COMはそこからランダムに選択する
またズレの情報が与えられ、範囲が狭まる
これを繰り返すことでいつか正解にたどり着くし、原理上これが最も効率的な推測方法と考えられる

ズレの情報は
・推測した数
・(i,j)
で完全に定まる。

数の集合を配列で与えているとして、ズレの情報が与えられた時、どうやってこれを狭めるか。
要は与えられた情報的にあり得るものだけを残せば良い。

最初の数の集合をG0とする。
最初の推測から得た情報I1によってG0から狭まった数の集合をG1とする。
n回目の推測から得た情報InによってG(n-1)から狭まった数の集合をGnとする。（GnはInとG(n-1)から生成される。）
当然G0>=G1>=...>=Gn>=...が成立する。

G(n-1)からG(n)を作るアルゴリズム
for i in range(|G(n-1)|):
  if G(n-1)のi番目の数が情報Inに適合する:
    それをG(n)に含める
  else:
    それをG(n)に含めない

Gを作る配列の構造
一つの配列を使いまわす
・・・[適合情報][数]・・・
という構造とする。数は桁ごとに格納する。（0983などの数は983になってしまう）
最初は
num_list = [True][0][0][0][0][True][0][0][0][1][True][0][0][0][2]...[True][9][9][9][9]
である。つまりi番目の数とその情報は5i~5i+4までに格納されている。i番目の数のj桁目はnum_list[5i+(5-j)]に格納されている。

|G(n-1)|を計算するアルゴリズム
trueである適合情報の個数を求めれば良い
i番目の数の適合情報は5iに格納されている
for i in range(10000) //0000~9999まで数は10000個ある
  if num_list[5i]がTrue:
    


メモ
pythonをatom上で実行できるようにするやつ便利すぎ。
